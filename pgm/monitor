/*************************************************************************************
                                 MONITOR
                           ===================
****************************************************************************************/

/* -----------------------------------------------------------------------------------
   MainLoop
-------------------------------------------------------------------------------------- */
MonSysMainLoop:
if ProcessInitialized = 0 then do

   nbLineDbg = 0
   Call SysCls
   if SetQueue( SysVars.SysQueue ) = "" then do

      Say "ERROR SETTING QUEUE IN MAINLOOP !"
      Return

   End

   Address SYSTEM '#rm log/* 1>/dev/null 2>&1'
   Address SYSTEM '#rm dbg/* 1>/dev/null 2>&1'
   Address SYSTEM 'rm cmd/.rexx 1>/dev/null 2>&1' /* */

   ProcessInitialized   = 1
   LocalProcess.0       = 0
   MessageReSend.0      = 0
   LockOwner.0          = 0
   DoChainLock          = 1
   LockRemoved          = 0
   LockAsked.0          = 0
   TimeToResend         = Time('E') + SysVars.SysLoopResend
   SysCancelTime        = 20
   SysStopAsked         = 0
   SysStopRedo          = 0
   SysNbWait            = 0

   SysHookProc.0        = 0
   nbSysHookProc        = 0
   HookProcess          = 0
   LockProcess          = 0

   msgResult            = SysVars.SysLCommit
   ForceTimeOut         = Time('E') + SysVars.SysLoopForceTO

End

Call ThrowLogM ProcessName, "UP"

Do ForEver

   CtrlAttn = 0
   SysCmd   = WaitMessage( , SysVars.SysLoopWM )
   Call getWSOCKIP

   if Time('E') >= ForceTimeOut then do

      ForceTimeOut = Time('E') + SysVars.SysLoopForceTO
      Call PushData SysVars.SysLTimeOut

   End

   if SysCmd = SysVars.SysLTimeOut then do

      if TimeToResend < Time('E') & MessageReSend.0 > 0 then do

         Rc             = ReSendMessage()
         TimeToResend   = Time('E') + SysVars.SysLoopResend

      End

      if LockAsked.0 > 0 & LockRemoved = 1 then
         Call TryLockAsked

      if SysNbWait > 0 then
         Call TryWakeUp

      Call QueryTime

   End
   Else
   if SysCmd = SysVars.SysLHalt then
      SysStopAsked = 1
   Else do

      smlRc = TrtSysCmd( SysCmd )
      Call LinkHookProc
      /*SysStopRedo = 0*/

   End

   if CtrlAttn = 1 | SysStopAsked = 1 then do
      Call ThrowLogM ProcessName, "SHUTTING DOWN"
      Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Arrêt du process demandé ..."
      Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Il y a actuellement "NumberProcess" process actifs"
      Call StopAllProcess
      SysVars.SysStopping  = 1
      SysStopAsked         = 0
   End

   if SysVars.SysStopping = 1 then do
      if NumberProcess <= 1 then Do
         Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Il n'y a plus de process actif ..."
         Leave
      End

      SysStopRedo = SysStopRedo + 1
      if SysStopRedo > SysVars.SysStopRedoT / 2 then do
         Call StopAllProcess
         Call Sleep SysVars.SysLoopDelay
      end

      if SysStopRedo > SysVars.SysStopRedoT then
         SysStopAsked = 2

   End

   if SysStopAsked = 2 then  Do
      Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Arrêt du moniteur forcé !"
      Leave
   End

End

Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Fin de la boucle principale"
Call ThrowLogM ProcessName, "DOWN"
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   SendToAll
-------------------------------------------------------------------------------------- */
SendToAll:
Parse arg staId, staMsg
Do stamI = 1 to LocalProcess.0

   stamQ = LocalProcess.stamI

   if stamQ \= "" then
      Rc = LinkMessage( stamQ, staId, staMsg )

End
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   StopAllProcess
-------------------------------------------------------------------------------------- */
StopAllProcess:

Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Purge des queues system"
Address SYSTEM 'rxqueue 'SysVars.SysEtatQueue' /clear'
Address SYSTEM 'rxqueue 'CpuQueue' /clear'
Address SYSTEM 'rxqueue 'SysVars.SysQueue' /clear'
Do mI = 1 to LocalProcess.0

   mQ = LocalProcess.mI

   if mQ \= "" then do
      do kI = 1 to LocalProcess.mQ.0
         tQ = LocalProcess.mQ.kI
         if tQ \= "" then do
            Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Purge de "tQ
            Address SYSTEM 'rxqueue 'tQ' /clear'
         End
      End
      Rc = CancelLoopForProcess( mQ )
      Rc = LinkMessage( mQ, "SYS_STOP", SysVars.SysLEnd )
      Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "Arrêt demandé pour "mQ

   End

End
SysVars.SysStopping = 1
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   TrtSysCmd
-------------------------------------------------------------------------------------- */
TrtSysCmd:
Parse arg TheCmd

if Left( TheCmd, 1 ) = '{' then do

   Parse var TheCmd '{'ReSendNum'}'TheCmd
   ReSendNum = ReSendNum + 1

End
Else
   ReSendNum = 0

Parse var TheCmd msgId'~'msgFrom'~'msgTo'~'msgDate'~'msgTime'#'msgData


if Pos( ':', msgId ) > 0 then do
   Parse var msgId msgId':'AnswerQueue
End
Else AnswerQueue = ""


if MsgLevelDisplayDebug = "YES" then
   Say "*DBG* Id="msgId", From="msgFrom", To="msgTo", Data="msgData

if LogFileNameDbg \= "" then
   Rc = LineOut( LogFileNameDbg, "*DBG* Id="msgId", From="msgFrom", To="msgTo", Data="msgData )

if msgTo = SysVars.SysMonName then
   Call TrtSysMonCmd
else do

   if AnswerQueue \= "" then AnswerQueue = ":"AnswerQueue

   if FindProcess( msgTo ) > 0 then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )
      Call Printf Pn"("Dj")", MsgLLevelDisplaySend, "TO "msgTo": "msgData

      Tm = LinkMessage( msgTo, msgId''AnswerQueue, msgData )
      if Tm = 0 then Call Printf SysVars.SysMonName, "ERROR", "Impossible de rediriger le message."

   End
   Else Do
      Call AddReSendMessage TheCmd, ReSendNum
      if ReSendNum = 0 then
         Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "PUSHED To="msgTo", Data="msgData
   End

   AnswerQueue = ""
End

If AnswerQueue \= "" then
   Rc = LinkMessageQ( AnswerQueue, "SYS_ACK", msgResult )

msgResult = SysVars.SysLCommit
Return 1
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   TrtSysMonCmd
-------------------------------------------------------------------------------------- */
TrtSysMonCmd:

Select

   When msgId = "SYS_BEGINPROCESS" then do

      dI = AddProcess( msgFrom )
      Call Printf SysVars.SysMonName, "ADD", FormatQueue( msgFrom, 'X' )

      Rc          = LinkMessageQ( FormatQueue( msgFrom ), "SYS_INIT", SysVars.SysLInit )
      HookProcess = 1

   End

   When msgId = "SYS_ENDPROCESS" then do

      Call RemoveProcess msgFrom
      Call RemoveLockPro FormatQueue( msgFrom )

      Call Printf SysVars.SysMonName, "REMOVE", FormatQueue( msgFrom, 'X' )
      HookProcess = 1
      LockProcess = 1

   End

   When msgId = "SYS_BEGINWAIT" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )

      SysNbWait                  = SysNbWait + 1
      LocalProcess.Pn.dJ.Wait    = 1
      if msgData > 0 then
         LocalProcess.Pn.dJ.WaitT   = Time('E') + msgData

      Rc = LinkMessageQ( Qn, "SYS_BEGINWAIT", SysVars.SysLCommit )
      Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "WAIT "FormatQueue( msgFrom, 'X' )"("Dj")"
      HookProcess = 1

   End

   When msgId = "SYS_ENDWAIT" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )

      SysNbWait                  = SysNbWait - 1
      LocalProcess.Pn.dJ.Wait    = 0
      LocalProcess.Pn.dJ.WaitT   = 0

      Rc = LinkMessageQ( Qn, "SYS_ENDWAIT", SysVars.SysLCommit )
      Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "WAKE "FormatQueue( msgFrom, 'X' )"("Dj")"
      HookProcess = 1

   End

   When msgId = "SYS_DISPLAY" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )

      dJ = FindSubProcess( Qn )
      Call Printf Pn"("dJ")", MsgLLevelDisplayDebug, msgData

   End

   When msgId = "SYS_ETAT" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )

      LocalProcess.Pn.dJ.Etat = msgData
      if FindHookProc( Qn ) = 0 then
         HookProcess = 1

   End

   When msgId = "SYS_BEGINLOOP" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )

      LocalProcess.Pn.dJ.Loop = msgData
      if FindHookProc( Qn ) = 0 then
         HookProcess = 1

   End

   When msgId = "SYS_ENDLOOP" then do

      Pn = FormatQueue( msgFrom, 'X' )
      Qn = FormatQueue( msgFrom )
      dJ = FindSubProcess( Qn )

      LocalProcess.Pn.dJ.Loop = ''
      if FindHookProc( Qn ) = 0 then
         HookProcess = 1

   End

   When msgId = "SYS_BEGINSTAT" then
      Call SendToAll "SYS_BEGINSTAT", ""

   When msgId = "SYS_ENDSTAT" then
      Call SendToAll "SYS_ENDSTAT", ""

   When msgId = "SYS_STOP" then do

      If Translate( msgData ) = "FORCE" then
         SysStopAsked = 2
      Else
         SysStopAsked = 1

   End

   /* La cmd END ne parvient pas a un process en wait - si waitmessage - donc
      il faut tuer la boucle */
   When msgId = "SYS_KILLPROCESS" then do

      if msgData \= "" then do
         Rc = CancelLoopForProcess( msgData )
         Rc = LinkMessage( msgData, "SYS_STOP", SysVars.SysLEnd )

      End

   End

   When msgId = "SYS_ANSWERE" then do

      Parse Var msgData Qn":"msgData
      Rc = LinkMessageQ( Qn, "SYS_ACK", msgData )

   End

   When msgId = "SYS_LOCK" then do

      Parse var msgData lkRsrc":"lkMode":"lkWait

      Pn = FormatQueue( msgFrom, "X" )
      Qn = FormatQueue( msgFrom )
      Rc = AddLock( Qn, lkRsrc, lkMode )
      if Rc > 0 then
         Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "LOCK: "Pn":"msgData
      Else
      if Rc = 0 then do
         if lkWait = "WAIT" then do
            Rc = CheckDeadLock( Qn, lkRsrc )
            if Rc = 0 then do
               Call AddLockAsked Qn, AnswerQueue, lkRsrc, lkMode
               Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "ASK LOCK: "Pn":"Qn":"msgData
               AnswerQueue = ""
            End
            Else
               msgResult = SysVars.SysLDeadLock
         End
         Else
            msgResult = SysVars.SysLBusy
      End
      LockProcess = 1

   End

   When msgId = "SYS_UNLOCK" then do

      Pn = FormatQueue( msgFrom, "X" )
      Qn = FormatQueue( msgFrom )
      Call RemoveLock Qn, msgData
      LockProcess = 1

   End

   When msgId = "SYS_HOOK" then do

      Pn    = FormatQueue( msgFrom, "X" )
      Qn    = FormatQueue( msgFrom )
      hData = Translate( Strip( msgData ))

      Select

         When Left( hData, 4 ) = "ADD:" then do

            Parse var hData "ADD:"What
            Call AddHookProc Qn, What

         End

         When hData = "REMOVE" then do

            If RemoveHookProc( Qn ) = 0 then
               Nop

         End

         When Left( hData, 5 ) = "LIST:" then do

            Parse var hData "LIST:"What":"Qn

            Select

               When What = "PROCESS" then
                  Call FillProcess Qn

               When What = "LOCKS" then
                  Call FillLocks Qn

               OtherWise

                  Nop

            End

         End

         OtherWise
            Call Printf Pn, "ERROR", "INVALID HOOK COMMAND"

      End

   End

   When msgId = "USR_MSG" then do

      msgData = Translate( msgData )

      Select

         When msgData = SysVars.SysLEnd then

            SysStopAsked = 1

         When msgData = "LOCK" then

            LockedProcess = 1

         When msgData = "UNLOCK" then

            LockedProcess = 0

         When msgData = "TRUNCLOG" then

            if LogFileName \= "" then do

               Status = Stream( LogFileName, 'c', 'close' )
               Address SYSTEM 'cat 'LogFileName' >> 'LogFileName'.trc '
               Address SYSTEM 'rm 'LogFileName' 1>/dev/null 2>&1'
               Status = Stream( LogFileName, 'c', 'open write' )

            End

         When msgData = "DUMPVARIABLES" then DO

            if SysVars.SysRacine = "" then
               SysVars.SysRacine = GetProfileString( , "LOG", "RACINE", "" )
            if SysVars.SysRacine \= "" then do
               soQ    = FormatQueue( SysVars.SysWhoAmI )
               soName = SysVars.SysRacine"/"soQ".dumpvariables"
               Call SysDumpVariables soName
            End

         End

         OtherWise

            Call Printf SysVars.SysMonName, "WARNING", "IGNORED "msgId"/"msgData

      End

   End

   OtherWise

      Call Printf SysVars.SysMonName, "WARNING", "IGNORED "msgId"/"msgData

End
Return
/* =================================================================================== */

/* -----------------------------------------------------------------------------------
   MonitorStartQueueSys
-------------------------------------------------------------------------------------- */
MonitorStartQueueSys:
msqsRC = Value("Rxstack_run",,Share)
If msqsRC \= "NO" & SysVars.FirstInstance = 1 Then Do
   Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Démarrage du service de gestion des files d'attente ..."
   Address SYSTEM 'rxstack -d'
   Address SYSTEM 'sleep 1'
End
Else
   Rc = 0
Return Rc
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   MonitorStopQueueSys
-------------------------------------------------------------------------------------- */
MonitorStopQueueSys:
msqsRC = Value("Rxstack_run",,Share)
If msqsRC \= "NO" & SysVars.FirstInstance = 1 Then Do
   If TheFirstQueue = SysVars.SysQueue Then Do
      Call Printf SysVars.SysMonName, MsgLLevelDisplayOther, "Arrêt du service de gestion des files d'attente ..."
      Address SYSTEM 'rxstack -k'
      Address SYSTEM 'ps > /tmp/monitor.ps.list'
      Do While Lines('/tmp/monitor.ps.list') > 0
         a=LineIn('/tmp/monitor.ps.list')
         if pos('rxstack',a) > 0 then do
            b=word(a,1)
            'kill 'strip(b)
            leave
         end
      end
   End
   Else
      Rc = 2
End
Return Rc
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   MonitorPrologue
-------------------------------------------------------------------------------------- */
MonitorPrologue:
If MonitorStartQueueSys() = 0 Then
   TheFirstQueue = AllocQueue( SysVars.SysQueue )
Else
   TheFirstQueue = ""
/***********************************************
if TheFirstQueue \= SysVars.SysQueue then do
   Say "Monitor déjà actif !"
   do I = 1 to LocalQueue.0
      if LocalQueue.I \= "" then
         Call RxQueue 'Delete', LocalQueue.I
   End
   exit
End
********/

/* Libells */
MsgLLevelDisplaySyst  = "LEVEL_SYSTEM"
MsgLLevelDisplayRecv  = "LEVEL_RECEIVE"
MsgLLevelDisplaySend  = "LEVEL_SEND"
MsgLLevelDisplayOther = "LEVEL_OTHERS"
MsgLLevelDisplayDebug = "LEVEL_DEBUG"

/* Rechercher dans .INI */
MsgLevelDisplaySyst  = GetProfileString( , "DISPLAY", MsgLLevelDisplaySyst, "YES" )
MsgLevelDisplayRecv  = GetProfileString( , "DISPLAY", MsgLLevelDisplayRecv, "YES" )
MsgLevelDisplaySend  = GetProfileString( , "DISPLAY", MsgLLevelDisplaySend, "YES" )
MsgLevelDisplayOther = GetProfileString( , "DISPLAY", MsgLLevelDisplayOther, "YES" )
MsgLevelDisplayDebug = GetProfileString( , "DISPLAY", MsgLLevelDisplayDebug, "NO" )
LogFileName          = GetProfileString( , "LOG", "FileName", "" )
LogFileNameDbg       = GetProfileString( , "LOG", "FileNameDebug", "" )

if SysVars.FirstInstance then do
    if AllocQueue( CpuQueue ) = "" then do
       Say "Impossible de creer "CpuQueue" !"
       do I = 1 to LocalQueue.0
          if LocalQueue.I \= "" then
             Call RxQueue 'Delete', LocalQueue.I
       End
       Exit
    End

    if AllocQueue( SysVars.SysEtatQueue ) = "" then do
       Say "Impossible de creer "SysVars.SysEtatQueue" !"
       do I = 1 to LocalQueue.0
          if LocalQueue.I \= "" then
             Call RxQueue 'Delete', LocalQueue.I
       End
       Exit
    End
End

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   Printf
-------------------------------------------------------------------------------------- */
Printf:
Parse arg pfFrom, pfLevel, pfInfos

pfDisplay = 0
Select

   When pfLevel = MsgLLevelDisplaySyst then do
      pfSign = "$"
      if MsgLevelDisplaySyst = 'YES' then
         pfDisplay = 1
   End

   When pfLevel = MsgLLevelDisplayRecv then do
      pfSign = "<"
      if MsgLevelDisplayRecv = 'YES' then
         pfDisplay = 1
   End

   When pfLevel = MsgLLevelDisplaySend then do
      pfSign = ">"
      if MsgLevelDisplaySend = 'YES' then
         pfDisplay = 1
   End

   When pfLevel = "ERROR" then do
      pfSign    = "!"
      pfDisplay = 1
   End

   When pfLevel = "WARNING" then do
      pfSign    = "?"
      pfDisplay = 1
   End

   When pfLevel = "ADD" then do
      pfSign    = "+"
      pfDisplay = 1
      pfFrom    = pfInfos
      pfInfos   = ""
   End

   When pfLevel = "REMOVE" then do
      pfSign    = "-"
      pfDisplay = 1
      pfFrom    = pfInfos
      pfInfos   = ""
   End

   OtherWise
      pfSign = "%"
      if MsgLevelDisplayOther = 'YES' then
         pfDisplay = 1

End

if pfDisplay = 1 then do

   D        = Date('S')
   T        = Left( Time('L'), 11 )
   zFrom    = MkSpace( pfFrom, 30 )
   zLevel   = MkSpace( pfLevel, 15 )

   ZoneInfo = D'-'T' 'pfSign''zFrom''pfInfos
   Say ZoneInfo
   If wsockIP \= "" Then 'wsock 'wsockIP' 'wsockPort' "WFMVM 'ZoneInfo'" > /dev/null 2>&1'
   Call SysLog ZoneInfo
End
Return
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   SysLog
-------------------------------------------------------------------------------------- */
SysLog:
Parse Arg LogData

if LogFileName \= "" then do

   Status = LineOut( LogFileName, logData )

End
Return


/* -----------------------------------------------------------------------------------
   LinkMessage
-------------------------------------------------------------------------------------- */
LinkMessage:
Parse Arg PmsgTo, PmsgId, PmsgData

if PmsgTo = SysVars.SysMonName then return 1

Pn   = FormatQueue( PmsgTo, 'X' )
lmI  = FindProcess( Pn )

If Translate(PmsgData) = SysVars.SysLEnd Then SysVars.SysPushQueue = 1

if lmI > 0 then do

   do lmJ = 1 to LocalProcess.Pn.0

      Qn = LocalProcess.Pn.lmJ
      Rc = LinkMessageQ( Qn, PmsgId, PmsgData )

   End

End

Return 1
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   LinkMessageQ
-------------------------------------------------------------------------------------- */
LinkMessageQ:
Parse Arg lQmsgTo, lQmsgId, lQmsgData

lQlmOk = LinkMessageAs( lQmsgTo, lQmsgId'~'lQmsgData )

Return lQlmOk
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   LinkMessageAs
-------------------------------------------------------------------------------------- */
LinkMessageAs:
Parse Arg QmsgTo, QmsgData

Signal On Syntax Name LinkMessageAsError

QlmOk = 0
Avant = SetQueue( QmsgTo )
if Avant \= "" then do

   If SysVars.SysPushQueue = 1 Then
      Call PushData QmsgData
   Else
      Call QueueData QmsgData
      
   QlmOk = 1
   Tm    = SetQueue( Avant )

End
Signal LinkMessageAsRetour

LinkMessageAsError:
QlmOk = 0
Tm    = SetQueue( Avant )

LinkMessageAsRetour:
Signal On Syntax Name StandardSyntax
SysVars.SysPushQueue = 0
Return QlmOk
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   AddProcess
-------------------------------------------------------------------------------------- */
AddProcess:
Arg pArg1

Pn = FormatQueue( pArg1, 'X' )
Qn = FormatQueue( pArg1 )

I = FindProcess( Pn )
if I = 0 then do

   I                          = LocalProcess.0
   I                          = I + 1
   LocalProcess.0             = I
   LocalProcess.I             = Pn
   LocalProcess.Pn.0          = 1
   LocalProcess.Pn.1          = Qn
   LocalProcess.Pn.1.Loop     = ''
   LocalProcess.Pn.1.Lock     = 0
   LocalProcess.Pn.1.Wait     = 0
   LocalProcess.Pn.1.WaitT    = 0
   LocalProcess.Pn.1.TAll     = 0
   LocalProcess.Pn.1.TCmd     = 0
   LocalProcess.Pn.1.TIdle    = 0
   LocalProcess.Pn.1.TElapsed = 0
   LocalProcess.Pn.1.Etat     = "?"

End
Else do

   J                          = LocalProcess.Pn.0
   J                          = J + 1
   LocalProcess.Pn.0          = J
   LocalProcess.Pn.J          = Qn
   LocalProcess.Pn.J.Loop     = ''
   LocalProcess.Pn.J.Lock     = 0
   LocalProcess.Pn.J.Wait     = 0
   LocalProcess.Pn.J.WaitT    = 0
   LocalProcess.Pn.J.TAll     = 0
   LocalProcess.Pn.J.TCmd     = 0
   LocalProcess.Pn.J.TIdle    = 0
   LocalProcess.Pn.1.TElapsed = 0
   LocalProcess.Pn.J.Etat     = "?"

End
NumberProcess = NumberProcess + 1

Return I
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindProcess
-------------------------------------------------------------------------------------- */
FindProcess:
Arg fpPn

do fpI = 1 to LocalProcess.0

   if LocalProcess.fpI = fpPn then Return fpI

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindSubProcess
-------------------------------------------------------------------------------------- */
FindSubProcess:
Arg fpQn

do fpI = 1 to LocalProcess.0
   fpQ = LocalProcess.fpI
   if fpQ = "" then Iterate

   do fpJ = 1 to LocalProcess.fpQ.0

      if LocalProcess.fpQ.fpJ = fpQn then Return fpJ

   End

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   RemoveProcess
-------------------------------------------------------------------------------------- */
RemoveProcess:
Arg pArg1

Pn = FormatQueue( pArg1, 'X' )
Qn = FormatQueue( pArg1 )

rpI = FindProcess( Pn )
if rpI > 0 then do

   if LocalProcess.Pn.0 > 1 then do

      do rpJ = 1 to LocalProcess.Pn.0

         if LocalProcess.Pn.rpJ = Qn then do

            LocalProcess.Pn.rpJ = ""
            Leave

         End

      End
      NumberProcess = NumberProcess - 1

   End
   Else do

      LocalProcess.rpI        = ""
      LocalProcess.Pn.0       = 0
      LocalProcess.Pn.1       = ""
      NumberProcess           = NumberProcess - 1

   End
End
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   CancelLoopForProcess
-------------------------------------------------------------------------------------- */
CancelLoopForProcess:
Arg clP
Signal On Syntax Name CancelLoopProcessRetour

do clI = 1 to LocalProcess.clP.0

   if LocalProcess.clP.clI.Loop \= "" then do
      Rc                         = CancelLoop( LocalProcess.clP.clI.Loop )
      LocalProcess.clP.clI.Loop  = ""
      HookProcess                = 1
   End

End

CancelLoopProcessRetour:
Signal On Syntax Name StandardSyntax

Return 1
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   CancelLoop
-------------------------------------------------------------------------------------- */
CancelLoop:
Arg clQ
Signal On Syntax Name CancelLoopRetour

clAvant = SetQueue( clQ )
if clAvant \= "" then do

   Call PushData '!STOP!'
   Tm = SetQueue( clAvant )

End

CancelLoopRetour:
Signal On Syntax Name StandardSyntax

Return 1
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   AddReSendMessage
-------------------------------------------------------------------------------------- */
AddReSendMessage:
Parse Arg rsmCmd, rsmNum

if rsmNum < SysVars.SysCancelTime then Do
   rsmI                 = MessageReSend.0 + 1
   MessageReSend.0      = rsmI
   MessageReSend.rsmI   = rsmCmd
   MessageReSend.rsmI.1 = rsmNum
End

Return
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   ReSendMessage
-------------------------------------------------------------------------------------- */
ReSendMessage:

ReSendMessageLoop:
do rsmJ = 1 to MessageReSend.0

   if MessageReSend.rsmJ \= "" then Do

      Call QueueData "{"MessageReSend.rsmJ.1"}"MessageReSend.rsmJ
      MessageReSend.rsmJ   = ""

   End

End
Drop MessageReSend.
MessageReSend.0 = 0

Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindLockX
-------------------------------------------------------------------------------------- */
FindLockX:
Parse Arg flkXRsrc, flkXWho

do flkXI = 1 to LockOwner.0

   do flkXJ = 1 to LockOwner.flkXI.0

      if LockOwner.flkXI.flkXJ = flkXRsrc & LockOwner.flkXI.flkXJ.0 = "X" then do

         if LockOwner.flkXI = flkXWho then
            Return 2
         Else
            Return 1

      End

   End

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindLockOwner
-------------------------------------------------------------------------------------- */
FindLockOwner:
Parse Arg flkoWho

do flkoI = 1 to LockOwner.0

   if LockOwner.flkoI = flkoWho then
      Return flkoI

End
Return 0
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   FindLockPoste
-------------------------------------------------------------------------------------- */
FindLockPoste:
Parse Arg flkpP, flkpRsrc

do flkpI = 1 to LockOwner.flkpP.0

   if LockOwner.flkpP.flkpI = flkpRsrc then
      return flkpI

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindLock
-------------------------------------------------------------------------------------- */
FindLock:
Parse Arg flkRsrc

do flkI = 1 to LockOwner.0

   if FindLockPoste( flkI, flkRsrc ) > 0 then
      Return flkI

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindProprio
-------------------------------------------------------------------------------------- */
FindProprio:
Parse Arg fdlRsrc

do fdlI = 1 to LockOwner.0
   do fdlJ = 1 to LockOwner.fdlI.0
      if LockOwner.fdlI.fdlJ = fdlRsrc & LockOwner.fdlI.fdlJ = "X" then
         Return dlOwner

   End
End
Return ""
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   CheckDeadLock
-------------------------------------------------------------------------------------- */
CheckDeadLock:
Parse Arg dlWho, dlRsrc

Return 0

/* Constituer une liste de lock en wait */
lkw.0    = 1
lkw.1.0  = dlRsrc
lkw.1.1  = FindProprio( dlRsrc )

do dlI = 1 to LockAsked.0
   dlJ         = dlI + 1
   lkw.dlJ.0   = LockAsked.dlI.2
   lkw.dlJ.1   = FindProprio( dlRsrc )
End

Return 0
/* =================================================================================== */


/* -----------------------------------------------------------------------------------
   AddLock
-------------------------------------------------------------------------------------- */
AddLock:
Parse Arg lkWho, lkRsrc, lkMode

if lkWho = "" | lkRsrc = "" | lkMode = "" | SysVars.SysStopping = 1 then return -1

lpR = FindLock( lkRsrc )

if lpR = 0 then do

   lpO = FindLockOwner( lkWho )

   if lpO = 0 then do

      lpO               = LockOwner.0 + 1
      LockOwner.0       = lpO
      LockOwner.lpO     = lkWho
      LockOwner.lpO.0   = 1
      LockOwner.lpO.1   = lkRsrc
      LockOwner.lpO.1.0 = lkMode
      LockOwner.lpO.1.1 = 1

      Return 1

   End
   Else do

      lpI                  = LockOwner.lpO.0 + 1
      LockOwner.lpO.0      = lpI
      LockOwner.lpO.lpI    = lkRsrc
      LockOwner.lpO.lpI.0  = lkMode
      LockOwner.lpO.lpI.1  = 1

      Return 1

   End

End
Else do

   lpX = FindLockX( lkRsrc, lkWho )        /* Un verrou type 'X' posé ? */
   if lpX = 1 then Return 0

   lpO = FindLockOwner( lkWho )

   if lpO = 0 then do

      lpP = FindLockPoste( lpR, lkRsrc )

      if LockOwner.lpR.lpP.0 = "X" then do

         Return 0

      End
      Else do

         if lkMode = "S" then do

            lpO               = LockOwner.0 + 1
            LockOwner.0       = lpO
            LockOwner.lpO     = lkWho
            LockOwner.lpO.0   = 1
            LockOwner.lpO.1   = lkRsrc
            LockOwner.lpO.1.0 = lkMode
            LockOwner.lpO.1.1 = 1

            Return 1

         End
         Else Do

            Return 0

         End

      End

   End
   Else do

      lpP = FindLockPoste( lpO, lkRsrc )

      if lpP = 0 then do

         lkI                  = LockOwner.lpO.0 + 1
         LockOwner.lpO.0      = lkI
         LockOwner.lpO.lkI    = lkRsrc
         LockOwner.lpO.lkI.0  = lkMode
         LockOwner.lpO.lkI.1  = 1

         Return 1

      End
      Else do

         lkI                  = LockOwner.lpO.lpP.1 + 1
         LockOwner.lpO.lpP.1  = lkI

         if lkMode = "X" then
            LockOwner.lpO.lpP.0  = lkMode

         Return 1

      End

   End

End

Return lkRc
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   RemoveLock
-------------------------------------------------------------------------------------- */
RemoveLock:
Parse Arg lkWho, lkRsrc

if lkWho = "" | lkRsrc = "" then return


lkO = FindLockOwner( lkWho )
if lkO > 0 then do

   lkP = FindLockPoste( lkO, lkRsrc )

   if lkP > 0 then do

      LockOwner.lkO.lkP.1  = LockOwner.lkO.lkP.1 - 1

      if LockOwner.lkO.lkP.1 = 0 then do

         Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "UNLOCK: "lkWho":"lkRsrc

         LockRemoved       = 1
         LockOwner.lkO.lkP = ""

      End

      if DoChainLock = 1 & LockRemoved = 1 then
         Call ChainLock

   End

End

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   ChainLock
-------------------------------------------------------------------------------------- */
ChainLock:

if SysVars.SysStopping = 1 then return

lrI = 0
do lkI = 1 to LockOwner.0

   lrI      = lrI + 1
   lr.lrI   = LockOwner.lrI

   if LockOwner.lkI.0 > 0 then do

      lrJ = 0
      do lkJ = 1 to LockOwner.lkI.0

         if LockOwner.lkI.lkJ \= "" then do

            lrJ            = lrJ + 1
            lr.lrI.lrJ     = LockOwner.lkI.lkJ
            lr.lrI.lrJ.0   = LockOwner.lkI.lkJ.0
            lr.lrI.lrJ.1   = LockOwner.lkI.lkJ.1

         End

      End

      lr.lrI.0 = lrJ

   End
   Else
      lr.lrI.0    = 0

End

Drop LockOwner.

do lkI = 1 to lrI

   LockOwner.lkI     = lr.lkI
   LockOwner.lkI.0   = lr.lkI.0

   do lkJ = 1 to lr.lkI.0

      LockOwner.lkI.lkJ    = lr.lkI.lkJ
      LockOwner.lkI.lkJ.0  = lr.lkI.lkJ.0
      LockOwner.lkI.lkJ.1  = lr.lkI.lkJ.1

   End

End

LockOwner.0 = lrI
Drop lr.

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   RemoveLockPro
-------------------------------------------------------------------------------------- */
RemoveLockPro:
Parse Arg lkWho

if SysVars.SysStopping = 1 then return
if lkWho = "" then return

DoChainLock = 0

Nothing = 1
lpO = FindLockOwner( lkWho )
if lpO > 0 then
   do rlI = 1 to LockOwner.lpO.0

      if LockOwner.lpO.rlI \= "" 0 then
         do rlJ = 1 to LockOwner.lpO.rlI.1
            Call RemoveLock lkWho, LockOwner.lpO.rlI
            Nothing = 0
         End

   End

do rlI = 1 to LockAsked.0

   if LockAsked.rlI.0 = lkWho then
      LockAsked.rlI.0 = ""

End

DoChainLock = 1
Call ChainLock

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   AddLockAsked
-------------------------------------------------------------------------------------- */
AddLockAsked:

Parse arg alWho, alTo, alRsrc, alMode

alI               = LockAsked.0 + 1
LockAsked.0       = alI
LockAsked.alI.0   = alWho
LockAsked.alI.1   = alTo
LockAsked.alI.2   = alRsrc
LockAsked.alI.3   = alMode

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   TryLockAsked
-------------------------------------------------------------------------------------- */
TryLockAsked:

if SysVars.SysStopping = 1 then return

do laI = 1 to LockAsked.0

   if LockAsked.laI.0 \= "" then do

      Rc = AddLock( LockAsked.laI.0, LockAsked.laI.2, LockAsked.laI.3 )
      if Rc > 0 then do

         Rc                = LinkMessageQ( LockAsked.laI.1, "SYS_ACK", SysVars.SysLCommit )
         LockAsked.laI.0   = ""
         Call Printf SysVars.SysMonName, MsgLLevelDisplaySyst, "LOCK: "LockAsked.laI.2":"LockAsked.laI.3

      End

   End

End
LockRemoved = 0
LockProcess = 1

Return
/* =================================================================================== */

/* -----------------------------------------------------------------------------------
   TryWakeUp
-------------------------------------------------------------------------------------- */
TryWakeUp:

Do twuI = 1 to LocalProcess.0

   twuPn = LocalProcess.twuI
   if twuPn \= "" then
      do twuJ = 1 to LocalProcess.twuPn.0

         if LocalProcess.twuPn.twuJ \= "" then
            if LocalProcess.twuPn.twuJ.Wait = 1 then
               if LocalProcess.twuPn.twuJ.WaitT > 0 & LocalProcess.twuPn.twuJ.WaitT <= Time('E') then do

                  twuQn = LocalProcess.twuPn.twuJ
                  twuMs = FormatMessage( twuPn"_"twuQn, SysVars.SysMonName, "SYS_ENDWAIT", 0 )
                  Call PushData twuMs

               End

      End

End

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   AddHookProc
-------------------------------------------------------------------------------------- */
AddHookProc:
Arg hpQn, hpWhat

hpI               = SysHookProc.0 + 1
SysHookProc.0     = hpI
SysHookProc.hpI   = hpQn
SysHookProc.hpI.1 = hpWhat
nbSysHookProc     = nbSysHookProc + 1

Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FindHookProc
-------------------------------------------------------------------------------------- */
FindHookProc:
Arg fhpQn

do fhpI = 1 to SysHookProc.0

   if SysHookProc.fhpI = fhpQn then
      Return fhpI

End
Return 0
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   RemoveHookProc
-------------------------------------------------------------------------------------- */
RemoveHookProc:
Arg hpQn

hpI = FindHookProc( hpQn )
if hpI > 0 then do

   SysHookProc.hpI = ""
   nbSysHookProc   = nbSysHookProc - 1
   Return nbSysHookProc

End
Return -1
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   LinkHookProc
-------------------------------------------------------------------------------------- */
LinkHookProc:

if SysVars.SysStopping = 1 then Return

do hpI = 1 to SysHookProc.0

   if SysHookProc.hpI \= "" then do

      if SysHookProc.hpI.1 = "PROCESS" & HookProcess = 1 then
         lhRc = LinkMessageQ( SysHookProc.hpI, "MSG_HOOK", msgId )
      Else
      if SysHookProc.hpI.1 = "LOCKS" & LockProcess = 1 then
         lhRc = LinkMessageQ( SysHookProc.hpI, "MSG_HOOK", msgId )

   End

End

HookProcess = 0
LockProcess = 0
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FillProcess
-------------------------------------------------------------------------------------- */
FillProcess:
Arg aQueue
if SysVars.SysStopping = 1 then Return

Signal On Syntax Name FillProcessPass

msgResult   = "ERROR"
Avant       = SetQueue( aQueue )

do I = 1 to LocalProcess.0

   Pn = LocalProcess.I
   if Pn = "" then Iterate

   Call QueueData Pn":"LocalProcess.Pn.0

   do J = 1 to LocalProcess.Pn.0

      if LocalProcess.Pn.J = "" then
         Call QueueData " "
      Else do
         Ln = LocalProcess.Pn.J
         Ln = Ln":"LocalProcess.Pn.J.Loop
         Ln = Ln":"LocalProcess.Pn.J.Lock
         Ln = Ln":"LocalProcess.Pn.J.Wait
         Ln = Ln":"LocalProcess.Pn.J.WaitT
         Ln = Ln":"LocalProcess.Pn.J.TAll
         Ln = Ln":"LocalProcess.Pn.J.TCmd
         Ln = Ln":"LocalProcess.Pn.J.TIdle
         Ln = Ln":"LocalProcess.Pn.J.TElapsed
         Ln = Ln":"LocalProcess.Pn.J.Etat

         Call QueueData Ln
      End

   End

End

msgResult = "DONE"
FillProcessPass:
Rc = SetQueue( Avant )

Signal On Syntax  Name StandardSyntax
Return
/* =================================================================================== */



/* -----------------------------------------------------------------------------------
   FillLocks
-------------------------------------------------------------------------------------- */
FillLocks:
Arg aQueue
if SysVars.SysStopping = 1 then Return

Signal On Syntax Name FillLocksPass

msgResult   = "ERROR"
Avant       = SetQueue( aQueue )

do I = 1 to LockOwner.0

   Pn = LockOwner.I
   if LockOwner.I.0 = 0 then Iterate
   Call QueueData Pn":"LockOwner.I.0

   do J = 1 to LockOwner.I.0

      Ln = LockOwner.I.J
      Ln = Ln":"LockOwner.I.J.0
      Ln = Ln":"LockOwner.I.J.1
      Call QueueData Ln

   End

End

Do I = 1 to LockAsked.0

   if LockAsked.I.0 \= "" then do

      Call QueueData "(#)"LockAsked.I.0":"1
      Call QueueData LockAsked.I.2":"LockAsked.I.3

   End

End

msgResult = "DONE"
FillLocksPass:
Rc = SetQueue( Avant )

Signal On Syntax  Name StandardSyntax
Return
/* =================================================================================== */

/* -----------------------------------------------------------------------------------
   QueryTime
-------------------------------------------------------------------------------------- */
QueryTime:
if SysVars.SysStopping = 1 then Return

Signal On Syntax Name QueryTimeError

Avant = SetQueue( CpuQueue )

nbQ = Queued()

do nbQ
   Ln = PullData()
   Parse var Ln pFrom"~"pAll":"pCmd":"pIdle":"pElapsed

   Pn = FormatQueue( pFrom, 'X' )
   Qn = FormatQueue( pFrom )
   dJ = FindSubProcess( Qn )

   if Pos( '.', pAll  ) = 0 then pAll  = pAll'.0000'
   if Pos( '.', pCmd  ) = 0 then pCmd  = pCmd'.0000'
   if Pos( '.', pIdle ) = 0 then pIdle = pIdle'.0000'
   if Pos( '.', pElapsed ) = 0 then pElapsed = pElapsed'.0000'

   pAll     = Format( pAll,, 2 )
   pCmd     = Format( pCmd,, 2 )
   pIdle    = Format( pIdle,, 2 )
   pElapsed = Format( pElapsed,, 2 )

   LocalProcess.Pn.dJ.TAll       = pAll
   LocalProcess.Pn.dJ.TCmd       = pCmd
   LocalProcess.Pn.dJ.TIdle      = pIdle
   LocalProcess.Pn.dJ.TElapsed   = pElapsed

   HookProcess = 1
End

QueryTimeError:
Apres = SetQueue( Avant )

Signal On Syntax  Name StandardSyntax
Return
/* =================================================================================== */
